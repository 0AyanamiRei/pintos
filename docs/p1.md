# Project 1: Threads

## Preliminaries

>Fill in your name and email address.

`Refrain520cc`

`EI Psy Congroo!`

`3244156674@qq.com`

>If you have any preliminary comments on your submission, notes for the
>TAs, please give them here.



>Please cite any offline or online sources you consulted while
>preparing your submission, other than the Pintos documentation, course
>text, lecture notes, and course staff.

## Before P1

管理线程状态的两个*DLL(Doubly linked list)*: `ready_list`和`all_list`, 前者记录`THREAD_READY`状态下的线程

两个特殊的线程: `initial_thread`和`idle_thread`


## Alarm Clock

>> 在 Pintos 项目中，禁用中断所能解决的唯一一类问题就是协调内核线程和中断处理程序之间的共享数据。

>> 由于中断处理程序不能休眠，因此无法获取锁。这意味着内核线程和中断处理程序之间共享的数据必须通过关闭中断来保护内核线程。

>> 本项目只需要从中断处理程序访问一点点线程状态。

>> 对于`alarm clock`来说，`timer interrupt`需要唤醒睡眠线程。

>> 在高级调度程序中，`timer interrupt`需要访问一些全局变量和每个线程变量。从内核线程访问这些变量时，需要禁用中断，以防止定时器中断干扰。

>> 在关闭中断时，要注意尽可能减少代码量。

>> 否则，您可能会丢失一些重要内容，如`timer ticks`或`input events`

>> 关闭中断也会增加中断处理延迟，如果过度，会让机器感觉迟钝。

>> 在`synch.c`中的同步原语本身就是通过禁用中断实现的。

>> 可能需要增加禁用中断时运行的代码量，但仍应尽量减少。

>> 禁用中断对调试很有用，如果你想确保某段代码不被中断的话。

>> 在提交项目之前，应删除调试代码。(不要直接注释掉，因为这样会使代码难以阅读）。

>> 提交的项目中不应有繁忙等待。

>> 调用 `thread_yield()` 的紧密循环是繁忙等待的一种形式。


***Task1 Bug log***

在`thread_create()`中, 创建的线程在`init_thread()`中被加入全局队列*all_list*, 若在此之后添加字段`sleep_time_`和`sleep_intervals_`的初始化, 则会出现一个空档期, 即*TCB*已加入*all_list*, 但是用于*Alarm Clock*的字段未初始化, 导致结果随机化, 所以需要将这些字段的初始化, 放在*TCB page*分配和将*TCB*加入*all_list*之间.


#### DATA STRUCTURES

>A1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.



#### ALGORITHMS

>A2: Briefly describe what happens in a call to timer_sleep(),
>including the effects of the timer interrupt handler.



>A3: What steps are taken to minimize the amount of time spent in
>the timer interrupt handler?



#### SYNCHRONIZATION

>A4: How are race conditions avoided when multiple threads call
>timer_sleep() simultaneously?



>A5: How are race conditions avoided when a timer interrupt occurs
>during a call to timer_sleep()?



#### RATIONALE

>A6: Why did you choose this design?  In what ways is it superior to
>another design you considered?



## Priority Scheduling

### Before Task2


***Exercise 2.1***: 在Pintos中实现优先级调度, 当`ready_list`中添加了优先级高于当前运行线程的线程时，当前线程应立即将处理器让给新线程, 同样，当线程在等待锁, 信号或条件变量时，优先级最高的等待线程应首先被唤醒, 线程可以随时提高或降低自己的优先级，但如果降低优先级，使自己不再拥有最高优先级，则必须立即让出 CPU。

线程优先级范围从`PRI_MIN(0)`到`PRI_MAX(63)`, 数字越小，优先级越低，因此优先级0是最低优先级，而优先级63是最高优先级, 初始线程优先级作为参数传递给`thread_create()`, 如果没有理由选择其他优先级，请使用`PRI_DEFAULT`, `PRI_XXX`宏定义在`threads/thread.h`, 不应更改其值。

---

***Hints***:

- For this exercise, **you need to consider all the scenarios** where the priority must be enforced. (必须考虑所有需要强制执行优先级的场景, 也就是说任何需要考虑线程执行顺序的地方, 都要把优先级考虑在内)
  1. For example, **when an alarm clock for a thread fires off**, that thread should be made ready again, which entails a priority check. (当线程的定时器或者闹钟结束的时候, 这个线程会被设置为`ready`, 这个时候就需要进行优先级检查)
  2. You can find some of these scenarios by **looking for places that modify** `ready_list` (directly and indirectly, rg can be helpful). (可以通过查找修改`ready_list`的地方来找到需要强制执行优先级的场景, 使用`rg(Ripgrep)`工具来帮你快速找到)
- **To yield the CPU**, you can check the thread APIs in `threads/thread.h`. (如果你想要让一个线程让出CPU, 查看`threads/thread.h`找到一些有用的APIs)
  1. Read the comment and implementation of the corresponding thread function in `threads/thread.c`. (阅读`threads/thread.c`中函数的注释和实现来理解它的工作原理)
  2. **That function may not be used in interrupt context** (i.e., should not call it inside an interrupt handler). (那个函数可能不允许在中断的上下文中使用, 比如在中断处理程序中)
- To yield the CPU in the **interrupt context**, you can take a look at functions in `threads/interrupt.c`. (如果你需要在中断的上下文中让出CPU, 查看`threads/interrupt.c`中的函数)

  pintos -v -k -T 60 --qemu -- -q  run priority-change
pintos -v -k -T 60 --bochs --gdb -- -q  run priority-change

target remote localhost:1234
file kernel.o


---

> **Exercise 2.1**

>> 对于2.1, 最明显的需要改动的地方是`thread_create`, 当一个线程被创建后, 需要检查优先级, 在这之前我们要看一下以下几个函数可能出现的上下文场景:

1. `thread_create()` 就目前的信息来看, 还没有发现在中断处理`intr_handler`以及`handler`中创建线程的情况, 所以可以暂且视为**不会在
2. `thread_unblock()`






#### DATA STRUCTURES

>B1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.


>B2: Explain the data structure used to track priority donation.
>Use ASCII art to diagram a nested donation.  (Alternately, submit a
>.png file.)



#### ALGORITHMS

>B3: How do you ensure that the highest priority thread waiting for
>a lock, semaphore, or condition variable wakes up first?



>B4: Describe the sequence of events when a call to lock_acquire()
>causes a priority donation.  How is nested donation handled?



>B5: Describe the sequence of events when lock_release() is called
>on a lock that a higher-priority thread is waiting for.



#### SYNCHRONIZATION

>B6: Describe a potential race in thread_set_priority() and explain
>how your implementation avoids it.  Can you use a lock to avoid
>this race?



#### RATIONALE

>B7: Why did you choose this design?  In what ways is it superior to
>another design you considered?



## Advanced Scheduler

#### DATA STRUCTURES

>C1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.



#### ALGORITHMS

>C2: How is the way you divided the cost of scheduling between code
>inside and outside interrupt context likely to affect performance?



#### RATIONALE

>C3: Briefly critique your design, pointing out advantages and
>disadvantages in your design choices.  If you were to have extra
>time to work on this part of the project, how might you choose to
>refine or improve your design?



>C4: The assignment explains arithmetic for fixed-point math in
>detail, but it leaves it open to you to implement it.  Why did you
>decide to implement it the way you did?  If you created an
>abstraction layer for fixed-point math, that is, an abstract data
>type and/or a set of functions or macros to manipulate fixed-point
>numbers, why did you do so?  If not, why not?