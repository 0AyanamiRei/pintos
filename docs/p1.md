# Project 1: Threads

## Preliminaries

>Fill in your name and email address.

`Refrain520cc`

`EI Psy Congroo!`

`3244156674@qq.com`

>If you have any preliminary comments on your submission, notes for the
>TAs, please give them here.



>Please cite any offline or online sources you consulted while
>preparing your submission, other than the Pintos documentation, course
>text, lecture notes, and course staff.

## Before P1

管理线程状态的两个*DLL(Doubly linked list)*: `ready_list`和`all_list`, 前者记录`THREAD_READY`状态下的线程

两个特殊的线程: `initial_thread`和`idle_thread`


## Alarm Clock

>> 在 Pintos 项目中，禁用中断所能解决的唯一一类问题就是协调内核线程和中断处理程序之间的共享数据。

>> 由于中断处理程序不能休眠，因此无法获取锁。这意味着内核线程和中断处理程序之间共享的数据必须通过关闭中断来保护内核线程。

>> 本项目只需要从中断处理程序访问一点点线程状态。

>> 对于`alarm clock`来说，`timer interrupt`需要唤醒睡眠线程。

>> 在高级调度程序中，`timer interrupt`需要访问一些全局变量和每个线程变量。从内核线程访问这些变量时，需要禁用中断，以防止定时器中断干扰。

>> 在关闭中断时，要注意尽可能减少代码量。

>> 否则，您可能会丢失一些重要内容，如`timer ticks`或`input events`

>> 关闭中断也会增加中断处理延迟，如果过度，会让机器感觉迟钝。

>> 在`synch.c`中的同步原语本身就是通过禁用中断实现的。

>> 可能需要增加禁用中断时运行的代码量，但仍应尽量减少。

>> 禁用中断对调试很有用，如果你想确保某段代码不被中断的话。

>> 在提交项目之前，应删除调试代码。(不要直接注释掉，因为这样会使代码难以阅读）。

>> 提交的项目中不应有繁忙等待。

>> 调用 `thread_yield()` 的紧密循环是繁忙等待的一种形式。\

```

pass tests/threads/mlfqs-fair-2
FAIL tests/threads/mlfqs-fair-20
FAIL tests/threads/mlfqs-nice-2
FAIL tests/threads/mlfqs-nice-10
FAIL tests/threads/mlfqs-block





pass tests/threads/mlfqs-fair-2
pass tests/threads/mlfqs-fair-20
FAIL tests/threads/mlfqs-nice-2
FAIL tests/threads/mlfqs-nice-10
FAIL tests/threads/mlfqs-block
20 of 27 tests failed.
```

### 关于task one 的一些注意事项
```
1.我们采用的唤醒方式中巧妙运用的自带的all_list列表,通过all_list列表巧妙的访问了所有的thread,然后我们可以通过访问thread->status and 
thread->internal_==-1，thread->sleep_time_==-1 来判断是否是block的并且是由sleep cause 的block.

*值得注意的是,在调用thread_create的时候会调用init_thread{这个函数做的事情就是初始化状态为block并且将其加入all_list队列(关闭了中断
确保了原子性))},所以我们得保证在加入队列的同时修改thread->internal_==-1，thread->sleep_time_==-1这样能保证唤醒的一定是sleep造成
的block(规避了thread->internal_和thread->sleep_time_随机值带来的麻烦)。


question:为何我们要保证在加入all_list的时候同时修改thread->internal_==-1，thread->sleep_time_==-1?


Answer:由于thread_create并没关闭中断,所以存在加入all_list之后但没修改thread->internal_==-1，thread->sleep_time_==-1发生中断,这个时候
就可能因为其在all_list列表中并且由于thread->internal_,thread->sleep_time_的随机值被wake_up函数唤醒,然后回到thread_create的时候再次调用
thread_unblock()就是出现assert错误

2.可能存在相同优先级并且都是最高优先级同时醒过来,所以我需要唤醒这个最高优先级队列,所以得开一个唤醒队列(里面存储的是最高优先级)
```



#### DATA STRUCTURES

>A1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.



#### ALGORITHMS

>A2: Briefly describe what happens in a call to timer_sleep(),
>including the effects of the timer interrupt handler.



>A3: What steps are taken to minimize the amount of time spent in
>the timer interrupt handler?



#### SYNCHRONIZATION

>A4: How are race conditions avoided when multiple threads call
>timer_sleep() simultaneously?



>A5: How are race conditions avoided when a timer interrupt occurs
>during a call to timer_sleep()?



#### RATIONALE

>A6: Why did you choose this design?  In what ways is it superior to
>another design you considered?



## Priority Scheduling

#### DATA STRUCTURES

>B1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.



>B2: Explain the data structure used to track priority donation.
>Use ASCII art to diagram a nested donation.  (Alternately, submit a
>.png file.)



#### ALGORITHMS

>B3: How do you ensure that the highest priority thread waiting for
>a lock, semaphore, or condition variable wakes up first?



>B4: Describe the sequence of events when a call to lock_acquire()
>causes a priority donation.  How is nested donation handled?



>B5: Describe the sequence of events when lock_release() is called
>on a lock that a higher-priority thread is waiting for.



#### SYNCHRONIZATION

>B6: Describe a potential race in thread_set_priority() and explain
>how your implementation avoids it.  Can you use a lock to avoid
>this race?



#### RATIONALE

>B7: Why did you choose this design?  In what ways is it superior to
>another design you considered?



## Advanced Scheduler

#### DATA STRUCTURES

>C1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.



#### ALGORITHMS

>C2: How is the way you divided the cost of scheduling between code
>inside and outside interrupt context likely to affect performance?



#### RATIONALE

>C3: Briefly critique your design, pointing out advantages and
>disadvantages in your design choices.  If you were to have extra
>time to work on this part of the project, how might you choose to
>refine or improve your design?



>C4: The assignment explains arithmetic for fixed-point math in
>detail, but it leaves it open to you to implement it.  Why did you
>decide to implement it the way you did?  If you created an
>abstraction layer for fixed-point math, that is, an abstract data
>type and/or a set of functions or macros to manipulate fixed-point
>numbers, why did you do so?  If not, why not?