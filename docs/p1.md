# Project 1: Threads

## Preliminaries

>Fill in your name and email address.

`Refrain520cc`

`EI Psy Congroo!`

`3244156674@qq.com`

>If you have any preliminary comments on your submission, notes for the
>TAs, please give them here.



>Please cite any offline or online sources you consulted while
>preparing your submission, other than the Pintos documentation, course
>text, lecture notes, and course staff.

## Before P1

管理线程状态的两个*DLL(Doubly linked list)*: `ready_list`和`all_list`, 前者记录`THREAD_READY`状态下的线程

两个特殊的线程: `initial_thread`和`idle_thread`


## Alarm Clock

>> 在 Pintos 项目中，禁用中断所能解决的唯一一类问题就是协调内核线程和中断处理程序之间的共享数据。

>> 由于中断处理程序不能休眠，因此无法获取锁。这意味着内核线程和中断处理程序之间共享的数据必须通过关闭中断来保护内核线程。

>> 本项目只需要从中断处理程序访问一点点线程状态。

>> 对于`alarm clock`来说，`timer interrupt`需要唤醒睡眠线程。

>> 在高级调度程序中，`timer interrupt`需要访问一些全局变量和每个线程变量。从内核线程访问这些变量时，需要禁用中断，以防止定时器中断干扰。

>> 在关闭中断时，要注意尽可能减少代码量。

>> 否则，您可能会丢失一些重要内容，如`timer ticks`或`input events`

>> 关闭中断也会增加中断处理延迟，如果过度，会让机器感觉迟钝。

>> 在`synch.c`中的同步原语本身就是通过禁用中断实现的。

>> 可能需要增加禁用中断时运行的代码量，但仍应尽量减少。

>> 禁用中断对调试很有用，如果你想确保某段代码不被中断的话。

>> 在提交项目之前，应删除调试代码。(不要直接注释掉，因为这样会使代码难以阅读）。

>> 提交的项目中不应有繁忙等待。

>> 调用 `thread_yield()` 的紧密循环是繁忙等待的一种形式。


***Task1 Bug log***

在`thread_create()`中, 创建的线程在`init_thread()`中被加入全局队列*all_list*, 若在此之后添加字段`sleep_time_`和`sleep_intervals_`的初始化, 则会出现一个空档期, 即*TCB*已加入*all_list*, 但是用于*Alarm Clock*的字段未初始化, 导致结果随机化, 所以需要将这些字段的初始化, 放在*TCB page*分配和将*TCB*加入*all_list*之间.


#### DATA STRUCTURES

>A1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.



#### ALGORITHMS

>A2: Briefly describe what happens in a call to timer_sleep(),
>including the effects of the timer interrupt handler.



>A3: What steps are taken to minimize the amount of time spent in
>the timer interrupt handler?



#### SYNCHRONIZATION

>A4: How are race conditions avoided when multiple threads call
>timer_sleep() simultaneously?



>A5: How are race conditions avoided when a timer interrupt occurs
>during a call to timer_sleep()?



#### RATIONALE

>A6: Why did you choose this design?  In what ways is it superior to
>another design you considered?



## Priority Scheduling

### 2.1

***Exercise 2.1***: 在Pintos中实现优先级调度, 当`ready_list`中添加了优先级高于当前运行线程的线程时，当前线程应立即将处理器让给新线程, 同样，当线程在等待锁, 信号或条件变量时，优先级最高的等待线程应首先被唤醒, 线程可以随时提高或降低自己的优先级，但如果降低优先级，使自己不再拥有最高优先级，则必须立即让出 CPU。

线程优先级范围从`PRI_MIN(0)`到`PRI_MAX(63)`, 数字越小，优先级越低，因此优先级0是最低优先级，而优先级63是最高优先级, 初始线程优先级作为参数传递给`thread_create()`, 如果没有理由选择其他优先级，请使用`PRI_DEFAULT`, `PRI_XXX`宏定义在`threads/thread.h`, 不应更改其值。

---

***Hints***:

- For this exercise, **you need to consider all the scenarios** where the priority must be enforced. (必须考虑所有需要强制执行优先级的场景, 也就是说任何需要考虑线程执行顺序的地方, 都要把优先级考虑在内)
  1. For example, **when an alarm clock for a thread fires off**, that thread should be made ready again, which entails a priority check. (当线程的定时器或者闹钟结束的时候, 这个线程会被设置为`ready`, 这个时候就需要进行优先级检查)
  2. You can find some of these scenarios by **looking for places that modify** `ready_list` (directly and indirectly, rg can be helpful). (可以通过查找修改`ready_list`的地方来找到需要强制执行优先级的场景, 使用`rg(Ripgrep)`工具来帮你快速找到)
- **To yield the CPU**, you can check the thread APIs in `threads/thread.h`. (如果你想要让一个线程让出CPU, 查看`threads/thread.h`找到一些有用的APIs)
  1. Read the comment and implementation of the corresponding thread function in `threads/thread.c`. (阅读`threads/thread.c`中函数的注释和实现来理解它的工作原理)
  2. **That function may not be used in interrupt context** (i.e., should not call it inside an interrupt handler). (那个函数可能不允许在中断的上下文中使用, 比如在中断处理程序中)
- To yield the CPU in the **interrupt context**, you can take a look at functions in `threads/interrupt.c`. (如果你需要在中断的上下文中让出CPU, 查看`threads/interrupt.c`中的函数)


```sh
priority-donate-condvar
make tests/threads/priority-donate-condvar.result


docker exec -it pintos bash
make tests/threads/priority-donate-multiple.result
rm tests/threads/priority-donate-one.output
pintos -v -k -T 60 --bochs  -- -q  run priority-donate-one < /dev/null 2> tests/threads/priority-donate-one.errors > tests/threads/priority-donate-one.output
target remote localhost:1234
file kernel.o
```

> **Exercise 2.1**

>> 更改过的函数:

1. `thread_create()`
2. `thread_unblock()`

>> 对于2.1, 最明显的需要改动的地方是`thread_create`, 当一个线程被创建后, 需要检查优先级, 在这之前我们要看一下以下几个函数可能出现的上下文场景:

1. `thread_create()` 就目前的信息来看, 还没有发现在中断处理`intr_handler`以及`handler`中创建线程的情况, 所以可以暂且视为**不会在中断上下文中使用**, 也就是`intr_context()`始终返回false; 是否开启外中断, 这是我们可操控的一个状态, 总之这个函数的上下文场景: **开启/关闭外中断**
2. `thread_unblock()` 这个函数出现的情况很多, 简言之**是否开启外中断, 是否在中断上下文均有可能**
3. `thread_yield()` 这是本实验让出CPU的重要函数, 但由于其不允许在中断上下文中使用, 所以需要考虑在哪儿使用.

因此我第一次修改在`thread_create()`中, 在调用`thread_unblock()`将新线程加入*ready_list*后, 比较当前**调用线程**和**被创建线程**的优先级, 如果需要当前线程让出CPU就调用`thread_yield()`

第二次修改, 我解决了在`thread_unblock()`中无法使用`thread_yield()`的问题, `intr_yield_on_return()`允许我们在中断处理程序结束后让出CPU, 而不是等待时间片耗尽, 这期间解决了一个BUG: 查看`idle()->sema_up()->thread_unblock()->thread_yield()....->thread_block()`, 会发现*idle*线程会调用两次`schedule()`, 如果只有*main*和*idle*线程在运行的情况, 一个线程会在中断中加入一次*ready_list*, 调用两次`schedule()`会出现*ready_list*为空, *idle*每次寻找下一个线程总是选择自己的死锁局面.

最终我选择第二次修改的方案, 一来是当下二者都能保证正确性, 二来是后者会频繁出现在锁, 信号量的唤醒机制里, 而这些地方正是我们需要考虑优先级的地方.

>> 从2.2回来, 第二处修改的地方来自调用链: `lock_release()->sema_up()->list_pop_front()->thread_unblock()`

`sema_up()`从`&sema->waiters`选择头节点唤醒, 没有考虑优先级, 所以这里需要修改一下, 调整为选择优先级最高的来解锁*unblock*即可


---

### 2.2

***Exercise 2.2***: 优先级调度的一个问题是 **优先级倒置**: 

分别考虑高、中、低优先级线程 H、M 和 L, 如果 H 需要等待 L（例如，等待 L 持有的锁），而 M 在就绪列表中，那么 H 将永远得不到 CPU，因为低优先级线程得不到任何 CPU 时间。解决这个问题的部分办法是，当 L 持有锁时，H 将其优先级 **捐献**给 L，然后在 L 释放（从而 H 获得）锁后，再收回优先级。

--- 

***Hints***

- You will need to account for all different situations in which priority donation is required. (您需要考虑需要优先捐赠的所有不同情况。)
- You must implement priority donation for locks. You need not implement priority donation for the other Pintos synchronization constructs.(您必须为锁实现优先级捐献。对于其他 Pintos 同步构造，则无需执行优先级捐献。)
- You do need to implement priority scheduling in all cases.(在所有情况下都需要执行优先级调度。)
- Be sure to handle multiple donations, in which multiple priorities are donated to a single thread.(请务必处理多重捐献，即向单个线程捐献多个优先级。)
- if H is waiting on a lock that M holds and M is waiting on a lock that L holds, then both M and L should be boosted to H's priority. (如果 H 正在等待 M 持有的锁，而 M 正在等待 L 持有的锁，那么 M 和 L 的优先级都应提升到 H 的优先级。)
- If necessary, you may impose a reasonable limit on depth of nested priority donation, such as 8 levels. (如有必要，可以对嵌套优先级捐赠的深度进行合理限制，例如 8 级。)

**Note**: if you support nested priority donation, you need to pass the `priority-donate-nest` and `priority-donate-chain` tests.

---

考虑最简单的例子, ABC三个线程, 优先级升序, 当线程B让cpu给C时, *ready_list*中有`main`, `idle`, `A`, `B`, 在C让出CPU之前要想办法把自己的优先级捐赠给A:

1. 线程C首先要知道锁在谁身上: `struct thread* locker = lock->holder`
2. 修改线程A的优先级为A, C之间的较大值, 现在C让出CPU后, 会选择A抢占
3. 线程A释放锁后, 需要复原自己的优先级, 为此需要记录下一些自己优先级的变化, 

**添加的结构**

考虑所有的情况, 根据场景, 我们需要的信息

1. 根据`test_priority_donate_one`~`test_priority_donate_multiple2`的测试用例, 对给定的锁, 我们

#### DATA STRUCTURES

>B1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.


>B2: Explain the data structure used to track priority donation.
>Use ASCII art to diagram a nested donation.  (Alternately, submit a
>.png file.)



#### ALGORITHMS

>B3: How do you ensure that the highest priority thread waiting for
>a lock, semaphore, or condition variable wakes up first?



>B4: Describe the sequence of events when a call to lock_acquire()
>causes a priority donation.  How is nested donation handled?



>B5: Describe the sequence of events when lock_release() is called
>on a lock that a higher-priority thread is waiting for.



#### SYNCHRONIZATION

>B6: Describe a potential race in thread_set_priority() and explain
>how your implementation avoids it.  Can you use a lock to avoid
>this race?



#### RATIONALE

>B7: Why did you choose this design?  In what ways is it superior to
>another design you considered?



## Advanced Scheduler

### 3.1

***Exercise 3.1*** 与优先级调度程序一样，高级调度程序也根据优先级选择运行线程。不过，**高级调度器不进行优先级捐赠**。

- 因此，我们建议您在开始高级调度程序的工作之前，先让优先级调度程序正常工作（优先级捐赠除外）, 您必须编写代码，允许我们在Pintos启动时选择调度算法策略。
- 默认情况下，优先级调度器必须处于激活状态，但我们必须能够通过`-mlfqs`内核选项选择**4.4BSD调度器**, 当`pintos_init()`中的`parse_options()`对选项进行解析时，传递该选项会将`threads/thread.h`中声明的`thread_mlfqs`设置为`true`, 启用**4.4BSD调度器**后，线程不再直接控制自己的优先级。
- 在函数调用`thread_create()`中`priority`参数必须被忽略, 以及任何`thread_set_priority()`调用
- 而`thread_get_priority()`则应返回调度程序设置的线程当前优先级。

---

***Hints***

- Double check the implementations of your fixed-point arithmetic routines (and ideally have some unit test for them). (仔细检查定点运算例程的实现（最好对其进行一些单元测试）)
- Some simple mistake in these routines could result in mysterious issues in your scheduler. (这些例程中的一些简单错误可能会导致调度程序出现神秘问题。)
- Efficiency matters a lot for the MLFQS exercise. (效率对`MLFQS`运算非常重要。)
- An inefficient implementation can distort the system. (低效的实现可能会歪曲系统。)
- Read the comment in the test case `mlfqs-load-avg.c`. (请阅读测试用例`mlfqs-load-avg.c`)
- In fact, the inefficiency in your alarm clock implementation can also influence your MLFQS behavior.(事实上，alarm clock的低效实现也会影响 MLFQS 的行为。)
- So double-check if your implementation there can be optimized. (因此，请仔细检查您的实现是否可以优化。)


#### DATA STRUCTURES

>C1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.



#### ALGORITHMS

>C2: How is the way you divided the cost of scheduling between code
>inside and outside interrupt context likely to affect performance?



#### RATIONALE

>C3: Briefly critique your design, pointing out advantages and
>disadvantages in your design choices.  If you were to have extra
>time to work on this part of the project, how might you choose to
>refine or improve your design?



>C4: The assignment explains arithmetic for fixed-point math in
>detail, but it leaves it open to you to implement it.  Why did you
>decide to implement it the way you did?  If you created an
>abstraction layer for fixed-point math, that is, an abstract data
>type and/or a set of functions or macros to manipulate fixed-point
>numbers, why did you do so?  If not, why not?


```
